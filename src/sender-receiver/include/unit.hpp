// include/unit.hpp                                                  -*-C++-*-
// ----------------------------------------------------------------------------
//  Copyright (C) 2020 Dietmar Kuehl http://www.dietmar-kuehl.de         
//                                                                       
//  Permission is hereby granted, free of charge, to any person          
//  obtaining a copy of this software and associated documentation       
//  files (the "Software"), to deal in the Software without restriction, 
//  including without limitation the rights to use, copy, modify,        
//  merge, publish, distribute, sublicense, and/or sell copies of        
//  the Software, and to permit persons to whom the Software is          
//  furnished to do so, subject to the following conditions:             
//                                                                       
//  The above copyright notice and this permission notice shall be       
//  included in all copies or substantial portions of the Software.      
//                                                                       
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES      
//  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND             
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT          
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,         
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING         
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR        
//  OTHER DEALINGS IN THE SOFTWARE. 
// ----------------------------------------------------------------------------
// This header is generated by combining the others, e.g., to make the
// implementation accessible on Compiler Explorer.

#ifndef INCLUDED_UNIT
#define INCLUDED_UNIT


#include <sys/types.h>
#include <functional>
#include <cstdint>
#include <atomic>
#include <utility>
#include <arpa/inet.h>
#include <system_error>
#include <sys/socket.h>
#include <type_traits>
#include <poll.h>
#include <cstddef>
#include <string>
#include <variant>
#include <memory>
#include <fcntl.h>
#include <cerrno>
#include <ostream>
#include <exception>
#include <chrono>
#include <stdexcept>
#include <queue>
#include <vector>
#include <unistd.h>
#include <netinet/in.h>
namespace cxxrt::dummy{}

#  if !defined(__clang__)
#    include <concepts>
#  else

#include <functional>
#include <type_traits>
#include <utility>

// ----------------------------------------------------------------------------

namespace std
{
    template <typename F, typename T>
    concept convertible_to
        =  std::is_convertible_v<F, T>
        && requires(std::add_rvalue_reference_t<F>(&f)())
           {
               static_cast<T>(f());
           }
        ;

    template <typename D, typename B>
    concept derived_from
        =  std::is_base_of_v<B, D>
        && is_convertible_v<D const volatile*, B const volatile*>
        ;

    template <typename F, typename... A>
    concept invocable
        =  requires(F&& f, A&&... a)
           {
               std::invoke(std::forward<F>(f), std::forward<A>(a)...);
           }
        ;

    template <typename T>
    concept destructible
        =  std::is_nothrow_destructible_v<T>
        ;
    template <typename T, typename... A>
    concept constructible_from
        =  destructible<T>
        && std::is_constructible_v<T, A...>;
        ;

    template <typename T>
    concept move_constructible
        =  constructible_from<T, T>
        && convertible_to<T, T>
        ;

    template <typename T>
    concept copy_constructible
        =  move_constructible<T>
        && constructible_from<T, T&>
        && convertible_to<T&, T>
        && constructible_from<T, T const&>
        && convertible_to<T const&, T>
        && constructible_from<T, T const>
        && convertible_to<T const, T>
        ;

    template <typename T>
    concept boolean_testable_impl
        = convertible_to<T, bool>
        ;

    template <typename T>
    concept boolean_testable
        =  boolean_testable_impl<T>
        && requires(T&& t)
           {
               { !std::forward<T>(t) } -> boolean_testable_impl;
           }
        ;

    template <typename S, typename T>
    concept weakly_equality_comparable_with
        =  requires(std::remove_reference<S> const& s,
                    std::remove_reference<T> const& t)
           {
               { s == t } -> boolean_testable;
               { s != t } -> boolean_testable;
               { t == s } -> boolean_testable;
               { t != s } -> boolean_testable;
           }
        ;
    template <typename T>
    concept equality_comparable
        =  weakly_equality_comparable_with<T, T>
        ;
}

// ----------------------------------------------------------------------------

#  endif
namespace cxxrt::execution {

    namespace customization
    {
        // --------------------------------------------------------------------

        template <typename E, typename F>
        concept has_member_execute
            = requires(E&& e, F&& f) {
                    std::forward<E>(e).execute(std::forward<F>(f));
                }
            ;
        template <typename E, typename F>
        concept has_execute
            =  !has_member_execute<E, F>
            && requires(E&& e, F&& f) {
                    execute(std::forward<E>(e), std::forward<F>(f));
                }
            ;

        // --------------------------------------------------------------------

        void execute();
        struct execute_t
        {
            template <typename E, typename F>
                requires has_member_execute<E, F>
            constexpr auto operator()(E&& e, F&& f) const
                noexcept(noexcept(std::forward<E>(e).execute(std::forward<F>(f))))
            {
                return std::forward<E>(e).execute(std::forward<F>(f));
            }
            template <typename E, typename F>
                requires has_execute<E, F>
            constexpr auto operator()(E&& e, F&& f) const
                noexcept(noexcept(execute(std::forward<E>(e), std::forward<F>(f))))
            {
                return execute(std::forward<E>(e), std::forward<F>(f));
            }
        };
        inline constexpr execute_t execute_cp{};

        // --------------------------------------------------------------------
    }

    inline namespace customization_points
    {
        inline constexpr auto execute      = customization::execute_cp;
    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace customization
    {
        // --------------------------------------------------------------------

        template <typename R>
        concept has_member_set_done
            = requires(R&& r) { std::forward<R>(r).set_done(); }
            ;
        template <typename R>
        concept has_set_done
            =  !has_member_set_done<R>
            && requires(R&& r) { set_done(std::forward<R>(r)); }
            ;

        // --------------------------------------------------------------------

        void set_done();
        struct set_done_t
        {
            template <typename R> requires has_member_set_done<R>
            constexpr auto operator()(R&& r) const
                noexcept(noexcept(std::forward<R>(r).set_done()))
            {
                return std::forward<R>(r).set_done();
            }
            template <typename R> requires has_set_done<R>
            constexpr auto operator()(R&& r) const
                noexcept(noexcept(set_done(std::forward<R>(r))))
            {
                return set_done(std::forward<R>(r));
            }
            template <typename R>
            constexpr auto operator()(R&& has_no_suitable_set_done) const = delete;
        };
        inline constexpr set_done_t set_done_cp{};

        // --------------------------------------------------------------------
    }

    inline namespace customization_points
    {
        inline constexpr auto set_done     = customization::set_done_cp;
    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace customization
    {
        // --------------------------------------------------------------------

        template <typename R, typename E>
        concept has_member_set_error
            =  requires(R&& r, E&& e) {
                   std::forward<R>(r).set_error(std::forward<E>(e));
               }
            ;
        template <typename R, typename E>
        concept has_set_error
            =  !has_member_set_error<R, E>
            && requires(R&& r, E&& e) {
                   set_error(std::forward<R>(r), std::forward<E>(e));
               }
            ;

        void set_error();
        struct set_error_t
        {
            template <typename R, typename E>
                requires has_member_set_error<R, E>
            constexpr auto operator()(R&& r, E&& e) const
                noexcept(noexcept(std::forward<R>(r).set_error(std::forward<E>(e))))
            {
                return std::forward<R>(r).set_error(std::forward<E>(e));
            }
            template <typename R, typename E>
                requires has_set_error<R, E>
            constexpr auto operator()(R&& r, E&& e) const
                noexcept(noexcept(set_error(std::forward<R>(r), std::forward<E>(e))))
            {
                return set_error(std::forward<R>(r), std::forward<E>(e));
            }
            template <typename R, typename E>
            constexpr auto operator()(R&& has_no_suitable_set_error, E&&) const = delete;
        };
        inline constexpr set_error_t set_error_cp{};

        // --------------------------------------------------------------------
    }

    inline namespace customization_points
    {
        inline constexpr auto set_error    = customization::set_error_cp;

    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace customization
    {
        // --------------------------------------------------------------------

        template <typename R, typename... A>
        concept has_member_set_value
            =  requires(R&& r, A&&... a) {
                   std::forward<R>(r).set_value(std::forward<A>(a)...);
               }
            ;
        template <typename R, typename... A>
        concept has_set_value
            =  !has_member_set_value<R, A...>
            && requires(R&& r, A&&... a) {
                   set_value(std::forward<R>(r), std::forward<A>(a)...);
               }
            ;
        
        // --------------------------------------------------------------------

        void set_value();
        struct set_value_t
        {
            template <typename R, typename... A>
                requires has_member_set_value<R, A...>
            constexpr auto operator()(R&& r, A&&...a) const
                noexcept(noexcept(std::forward<R>(r).set_value(std::forward<A>(a)...)))
            { 
                return std::forward<R>(r).set_value(std::forward<A>(a)...);
            }

            template <typename R, typename... A>
                requires has_set_value<R, A...>
            constexpr auto operator()(R&& r, A&&...a) const
                noexcept(noexcept(set_value(std::forward<R>(r), std::forward<A>(a)...)))
            { 
                return set_value(std::forward<R>(r), std::forward<A>(a)...);
            }
            template <typename R, typename... A>
            constexpr auto operator()(R&& has_no_suitable_set_value, A&&...) const
                = delete;
        };
        inline constexpr set_value_t set_value_cp{};

        // --------------------------------------------------------------------
    }

    inline namespace customization_points
    {
        inline constexpr auto set_value    = customization::set_value_cp;
    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution::detail

{
    template <typename, typename> struct as_invocable;
}

// ----------------------------------------------------------------------------

template <typename R, typename>
struct cxxrt::execution::detail::as_invocable
{
private:
    R* d_r;

public:
    explicit as_invocable(R& r) noexcept;
    as_invocable(as_invocable&& o) noexcept;
    ~as_invocable();

    void operator()() & noexcept;
};

// ----------------------------------------------------------------------------

template <typename R, typename X>
cxxrt::execution::detail::as_invocable<R, X>::as_invocable(R& r) noexcept
    : d_r(std::addressof(r))
{
}

template <typename R, typename X>
cxxrt::execution::detail::as_invocable<R, X>::as_invocable(as_invocable&& o) noexcept
    : d_r(std::exchange(o.d_r, nullptr))
{
}

template <typename R, typename X>
cxxrt::execution::detail::as_invocable<R, X>::~as_invocable()
{
    if (this->d_r) {
        execution::set_done(std::move(*this->d_r));
    }
}

template <typename R, typename X>
void cxxrt::execution::detail::as_invocable<R, X>::operator()() & noexcept
    try
    {
        execution::set_value(std::move(*this->d_r));
        this->d_r = nullptr;
    }
    catch (...)
    {
        execution::set_error(std::move(*this->d_r), std::current_exception());
        this->d_r = nullptr;
    }

// ----------------------------------------------------------------------------

namespace cxxrt::execution::detail

{
    template <typename E, typename F>
    concept executor_of_impl
        =  std::invocable<std::remove_cvref_t<F>&>
        && std::constructible_from<std::remove_cvref_t<F>, F>
        && std::move_constructible<std::remove_cvref_t<F>>
        && std::copy_constructible<E>
        && std::is_nothrow_copy_constructible_v<E>
        && std::equality_comparable<E>
        && requires(const E& e, F&& f) {
               execution::execute(e, (F&&)f);
           }
        ;
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution::detail

{
    // ------------------------------------------------------------------------

    template <template <template <typename...> class T,
                        template <typename...> class V> class>
    struct has_value_types;

    template <template <template <typename...> class V> class>
    struct has_error_types;

    // ------------------------------------------------------------------------

    template <typename S>
    concept has_sender_types
    =   requires
        {
            typename has_value_types<S::template value_types>;
            typename has_error_types<S::template error_types>;
            typename std::bool_constant<S::sends_done>;
        }
        ;

    // ------------------------------------------------------------------------
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace execution_detail
    {
        struct sender_base;
    }
    using execution_detail::sender_base;
}

// ----------------------------------------------------------------------------

struct cxxrt::execution::execution_detail::sender_base
{
};

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace sender_traits_detail
    {
        // --------------------------------------------------------------------

        struct void_receiver
        {
            void set_value() noexcept;
            void set_error(std::exception_ptr) noexcept;
            void set_done() noexcept;
        };

        // --------------------------------------------------------------------

        template <typename S,
                  bool = detail::has_sender_types<S>,
                  bool = false && execution::detail::executor_of_impl<S, execution::detail::as_invocable<void_receiver, S>>,
                  bool = std::derived_from<S, execution::sender_base>>
        struct base;

        template <typename S, bool E, bool B>
        struct base<S, true, E, B>;

        template <typename S, bool B>
        struct base<S, false, true, B>;

        template <typename S>
        struct base<S, false, false, true>;

        // --------------------------------------------------------------------
    }

    template<typename S>
    struct sender_traits;
}

// ----------------------------------------------------------------------------
// the primary template, indicating that it didn't get specialized.

template <typename, bool, bool, bool>
struct cxxrt::execution::sender_traits_detail::base
{
    using __unspecialized = void;
};

// ----------------------------------------------------------------------------
// The sender has nested value and error types defined

template <typename S, bool E, bool B>
struct cxxrt::execution::sender_traits_detail::base<S, true, E, B>
{
    template <template <typename...> class T,
              template <typename...> class V>
    using value_types = typename S::template value_types<T, V>;
    template <template <typename...> class V>
    using error_types = typename S::template error_types<V>;

    static constexpr bool sends_done = S::sends_done;
};

// ----------------------------------------------------------------------------
// The sender can use an invocable

template <typename S, bool B>
struct cxxrt::execution::sender_traits_detail::base<S, false, true, B>
{
    template <template <typename...> class T,
              template <typename...> class V>
    using value_types = V<T<>>;
    template <template <typename...> class V>
    using error_types = V<std::exception_ptr>;

    static constexpr bool sends_done = true;
};

// ----------------------------------------------------------------------------
// The sender is derived from sender_base.

template <typename S>
struct cxxrt::execution::sender_traits_detail::base<S, false, false, true>
{
};

// ----------------------------------------------------------------------------

template <typename S>
struct cxxrt::execution::sender_traits
    : cxxrt::execution::sender_traits_detail::base<S>
{
};

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace customization
    {
        // --------------------------------------------------------------------

        template <typename O>
        concept has_member_start
            = requires(O&& o) { std::forward<O>(o).start(); }
            ;

        template <typename O>
        concept has_start
            =  !has_member_start<O>
            && requires(O&& o) { start(std::forward<O>(o)); }
            ;

        // --------------------------------------------------------------------

        void start();
        struct start_t
        {
            template <typename O>
                requires has_member_start<O>
            constexpr auto operator()(O&& o) const
                noexcept(noexcept(std::forward<O>(o).start()))
            {
                return std::forward<O>(o).start();
            }
            template <typename O>
                requires has_start<O>
            constexpr auto operator()(O&& o) const
                noexcept(noexcept(start(std::forward<O>(o))))
            {
                return start(std::forward<O>(o));
            }
            template <typename O>
            constexpr auto operator()(O&& has_no_suitable_start) const = delete;
        };
        inline constexpr start_t start_cp{};

        // --------------------------------------------------------------------
    }

    inline namespace customization_points
    {
        inline constexpr auto start        = customization::start_cp;
    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::net

{
    class execution_context;
    template<typename T, typename Executor>
    class executor_binder;
    template<typename Executor>
    class executor_work_guard;
    class system_executor;
    class executor;
    template<typename Executor>
    class strand;
    class io_context;
    template<typename Clock> struct wait_traits;
    template<typename Clock, typename WaitTraits = wait_traits<Clock>>
    class basic_waitable_timer;
    using system_timer = basic_waitable_timer<std::chrono::system_clock>;
    using steady_timer = basic_waitable_timer<std::chrono::steady_clock>;
    using high_resolution_timer = basic_waitable_timer<std::chrono::high_resolution_clock>;
    template<typename Protocol>
    class basic_socket;
    template<typename Protocol>
    class basic_datagram_socket;
    template<typename Protocol>
    class basic_stream_socket;
    template<typename Protocol>
    class basic_socket_acceptor;
    template<typename Protocol, typename Clock = std::chrono::steady_clock,
             typename WaitTraits = wait_traits<Clock>>
    class basic_socket_streambuf;
    template<typename Protocol, typename Clock = std::chrono::steady_clock,
             typename WaitTraits = wait_traits<Clock>>
    class basic_socket_iostream;
    namespace ip {
        class address;
        class address_v4;
        class address_v6;
        template<typename Address>
        class basic_address_iterator;
        using address_v4_iterator = basic_address_iterator<address_v4>;
        using address_v6_iterator = basic_address_iterator<address_v6>;
        template<typename Address>
        class basic_address_range;
        using address_v4_range = basic_address_range<address_v4>;
        using address_v6_range = basic_address_range<address_v6>;
        class network_v4;
        class network_v6;
        template<typename InternetProtocol>
        class basic_endpoint;
        template<typename InternetProtocol>
        class basic_resolver_entry;
        template<typename InternetProtocol>
        class basic_resolver_results;
        template<typename InternetProtocol>
        class basic_resolver;
        class tcp;
        class udp;
    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template<typename O>
    concept operation_state
        =  std::destructible<O>
        && std::is_object_v<O>
        && requires(O& o) { { execution::start(o) } noexcept; }
        ;
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template <typename R, typename E = std::exception_ptr>
    concept receiver
        =  std::move_constructible<std::remove_cvref_t<R>>
        && std::constructible_from<std::remove_cvref_t<R>, R>
        && requires(std::remove_cvref_t<R>&& r, E&& e)
           {
               { execution::set_done(std::move(r)) } noexcept;
               { execution::set_error(std::move(r), std::forward<E>(e)) } noexcept;
           }
        ;
    
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template<typename R, typename... A>
    concept receiver_of
        =  receiver<R>
        && requires(std::remove_cvref_t<R>&& r, A&&... a)
           {
               execution::set_value(std::move(r), std::forward<A>(a)...);
           }
        ;

    template<typename R, typename... A>
    inline constexpr bool is_nothrow_receiver_of_v =
        receiver_of<R, A...> &&
        std::is_nothrow_invocable_v<decltype(set_value), R, A...>;
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template<typename S>
    concept sender
        =  std::move_constructible<std::remove_cvref_t<S>>
        && !requires { typename sender_traits<std::remove_cvref_t<S>>::__unspecialized; }
        ;
}

// ----------------------------------------------------------------------------

namespace cxxrt::net

{
    enum class fork_event {};
    class execution_context;

    class service_already_exists;

    template<typename Service>
    typename Service::key_type& use_service(execution_context& ctx);
    template<typename Service, typename... Args>
    Service& make_service(execution_context& ctx, Args&&... args);
    template<typename Service>
    bool has_service(execution_context const& ctx) noexcept;
}

// ----------------------------------------------------------------------------

class cxxrt::net::service_already_exists
    : public std::logic_error
{
};

// ----------------------------------------------------------------------------

class cxxrt::net::execution_context
{
public:
    class service;

    execution_context();
    execution_context(execution_context const&) = delete;
    execution_context& operator=(execution_context const&) = delete;
    virtual ~execution_context();

    void notify_fork(cxxrt::net::fork_event);

protected:
    void shutdown() noexcept;
    void destroy() noexcept;
};

// ----------------------------------------------------------------------------

class cxxrt::net::execution_context::service
{
private:
    execution_context& d_owner;
    
    virtual void shutdown() noexcept = 0;
    virtual void notify_fork(fork_event e);

protected:
    explicit service(execution_context& owner);
    service(service const&) = delete;
    service& operator=(service const&) = delete;
    virtual ~service();

    execution_context& context() noexcept;
};

// ----------------------------------------------------------------------------

inline cxxrt::net::execution_context&
cxxrt::net::execution_context::service::context() noexcept
{
    return this->d_owner;
}

// ----------------------------------------------------------------------------

namespace cxxrt::net::ip

{
    class address_v4;
    class v4_mapped_t;

    using uint_type = uint_least32_t;
    struct bytes_type { std::byte bytes[4]; };

    constexpr address_v4 make_address_v4(bytes_type const& bytes);
    constexpr address_v4 make_address_v4(uint_type val);
    constexpr address_v4 make_address_v4(v4_mapped_t, address_v6 const& a);
    address_v4 make_address_v4(char const* str);
    address_v4 make_address_v4(char const* str, std::error_code& ec) noexcept;
    address_v4 make_address_v4(std::string const& str);
    address_v4 make_address_v4(std::string const& str, std::error_code& ec) noexcept;
    address_v4 make_address_v4(std::string_view str);
    address_v4 make_address_v4(std::string_view str, std::error_code& ec) noexcept;
}

// ----------------------------------------------------------------------------

class cxxrt::net::ip::address_v4
{
public:
    using uint_type = uint_least32_t;
    struct bytes_type;

private:
    uint_type d_addr{};
    
    template <std::size_t S>
    char const* to_string(char (&a)[S]) const { return this->to_string(a, S); }
    char const* to_string(char* buffer, std::size_t size) const;

public:
    constexpr address_v4() noexcept = default;
    constexpr address_v4(const address_v4& a) noexcept = default;
    constexpr address_v4(const bytes_type&);
    explicit constexpr address_v4(uint_type a): d_addr(a) {};

    address_v4& operator=(const address_v4&) noexcept = default;

    constexpr bool is_unspecified() const noexcept;
    constexpr bool is_loopback() const noexcept;
    constexpr bool is_multicast() const noexcept;
    constexpr bytes_type to_bytes() const noexcept;
    constexpr uint_type to_uint() const noexcept { return this->d_addr; }
    template<typename Allocator = std::allocator<char>>
    std::basic_string<char, std::char_traits<char>, Allocator>
    to_string(Allocator const& a = Allocator()) const;

    static constexpr address_v4 any() noexcept;
    static constexpr address_v4 loopback() noexcept;
    static constexpr address_v4 broadcast() noexcept;

    bool operator== (address_v4 const&) const;
    bool operator<  (address_v4 const&) const;
    template <typename cT, typename Traits>
    friend std::basic_ostream<cT, Traits>&
    operator<< (std::basic_ostream<cT, Traits>&, address_v4 const&);
};

// ----------------------------------------------------------------------------

template<typename Allocator>
std::basic_string<char, std::char_traits<char>, Allocator>
cxxrt::net::ip::address_v4::to_string(Allocator const& a) const
{
    char buffer[32];
    return std::basic_string<char, std::char_traits<char>, Allocator>(
        this->to_string(buffer), a);
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace customization
    {
        // --------------------------------------------------------------------

        void bulk_execute(); //-dk:TODO
        struct bulk_execute_t
        {
        };
        inline constexpr bulk_execute_t bulk_execute_cp{};

        // --------------------------------------------------------------------

    }
    inline namespace customization_points
    {
        inline constexpr auto bulk_execute = customization::bulk_execute_cp;
    }

}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace customization
    {
        // --------------------------------------------------------------------

        template <typename S, typename R>
        struct as_operation
        {
            std::remove_cvref_t<S> d_s;
            std::remove_cvref_t<R> d_r;

            void start() noexcept;
        };

        // --------------------------------------------------------------------

        template <typename S, typename R>
        concept has_member_connect
            =  execution::sender<S>
            && requires(S&& s, R&& r){ std::forward<S>(s).connect(std::forward<R>(r)); }
            && execution::operation_state<decltype(std::declval<S>().connect(std::declval<R>()))>
            ;
        template <typename S, typename R>
        concept has_connect
            =  (!has_member_connect<S, R>)
            && execution::sender<S>
            && requires(S&& s, R&& r){ connect(std::forward<S>(s), std::forward<R>(r)); }
            && execution::operation_state<decltype(connect(std::declval<S>(), std::declval<R>()))>
            ;


        // --------------------------------------------------------------------

        void connect();
        struct connect_t
        {
            template <typename S, typename R>
                requires has_member_connect<S, R>
            constexpr auto operator()(S&& s, R&& r) const
                noexcept(noexcept(std::forward<S>(s).connect(std::forward<R>(r))))
            {
                return std::forward<S>(s).connect(std::forward<R>(r));
            }
            template <typename S, typename R>
                requires has_connect<S, R>
            constexpr auto operator()(S&& s, R&& r) const
                noexcept(noexcept(connect(std::forward<S>(s), std::forward<R>(r))))
            {
                return connect(std::forward<S>(s), std::forward<R>(r));
            }
            template <typename S, typename R>
                requires (!has_member_connect<S, R>)
                      && (!has_connect<S, R>)
                      && receiver_of<R>
                      && execution::detail::executor_of_impl<std::remove_cvref_t<S>,
                                                             execution::detail::as_invocable<std::remove_cvref_t<R>, S>>
            constexpr auto operator()(S&& s, R&& r) const
                noexcept(noexcept(as_operation{std::forward<S>(s), std::forward<R>(r)}))
            {
                return as_operation{std::forward<S>(s), std::forward<R>(r)};
            }

            template <typename S, typename R>
            constexpr auto operator()(S&& has_no_suitable_connect, R&& r) const = delete;
        };
        inline constexpr connect_t connect_cp{};

        // --------------------------------------------------------------------

    }

    inline namespace customization_points
    {
        inline constexpr auto connect      = customization::connect_cp;
    }

    template<typename S, typename R>
    using connect_result_t = std::invoke_result_t<decltype(connect), S, R>;

}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    // clang doesn't like that, yet: using invocable_archetype = decltype([]{});
    struct invocable_archetype
    {
        constexpr void operator()() const noexcept {}
    };
    static_assert(std::invocable<invocable_archetype&>);

    template<typename E>
    concept executor
        = execution::detail::executor_of_impl<E, execution::invocable_archetype>
        ;

}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template<typename E, typename F>
    concept executor_of
        = execution::detail::executor_of_impl<E, F>
        ;
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    struct receiver_invocation_error;
}

// ----------------------------------------------------------------------------

struct cxxrt::execution::receiver_invocation_error
    : std::runtime_error
    , std::nested_exception
{
    receiver_invocation_error() noexcept
        : std::runtime_error("invocation error")
        , std::nested_exception()
    {
    }
};

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace customization
    {
        // --------------------------------------------------------------------

        template <typename S>
        concept has_member_schedule
            =  requires(S&& s)
               {
                   std::forward<S>(s).schedule();
               }
            && execution::sender<decltype(std::declval<S>().schedule())>
            ;
        template <typename S>
        concept has_schedule
            =  !has_member_schedule<S>
            && requires(S&& s)
               {
                   schedule(std::forward<S>(s));
               }
            && execution::sender<decltype(schedule(std::declval<S>()))>
            ;

        // --------------------------------------------------------------------

        template<typename E>
        struct as_sender {
        private:
            E d_e;
        public:
            template<template<typename...> class T,
                     template<typename...> class V>
            using value_types = V<T<>>;
            template<template<typename...> class V>
            using error_types = V<std::exception_ptr>;
            static constexpr bool sends_done = true;

            explicit as_sender(E e) noexcept
                : d_e(std::forward<E>(e))
            {
            }
            template<typename R>
                requires execution::receiver_of<R>
            execution::connect_result_t<E, R> connect(R&& r) &&
            {
                return execution::connect(std::forward<E>(d_e), std::forward<R>(r));
            }
            template<typename R>
            requires receiver_of<R>
            execution::connect_result_t<E const&, R> connect(R&& r) const&
            {
                return execution::connect(d_e, std::forward<R>(r));
            }
        };

        // --------------------------------------------------------------------

        void schedule();
        struct schedule_t
        {
            template <typename S>
                requires has_member_schedule<S>
            constexpr auto operator()(S&& s) const
                noexcept(noexcept(std::forward<S>(s).schedule()))
            {
                return std::forward<S>(s).schedule();
            }

            template <typename S>
                requires has_schedule<S>
            constexpr auto operator()(S&& s) const
                noexcept(noexcept(schedule(std::forward<S>(s))))
            {
                return schedule(std::forward<S>(s));
            }

            template <typename S>
            requires (!has_member_schedule<S>)
                  && (!has_schedule<S>)
                  && execution::executor<S>
            constexpr auto operator()(S&& s) const
            {
                return as_sender<std::remove_cvref_t<S>>{s};
            }

            template <typename S>
            constexpr void operator()(S&&) const = delete;
        };
        inline constexpr schedule_t schedule_cp{};

        // --------------------------------------------------------------------
    }
    
    inline namespace customization_points
    {
        inline constexpr auto schedule     = customization::schedule_cp;
    }

}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template<typename S>
    concept scheduler
        =  std::copy_constructible<std::remove_cvref_t<S>>
        && std::equality_comparable<std::remove_cvref_t<S>>
        && requires(S&& s)
           {
               execution::schedule(std::forward<S>(s));
           }
        ;
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template<typename S, typename R>
    concept sender_to
        =  sender<S>
        && receiver<R>
        && requires(S&& s, R&& r)
           {
               execution::connect(std::forward<S>(s), std::forward<R>(r));
           }
        ;
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace customization
    {
        // --------------------------------------------------------------------

        template <typename S, typename R>
        concept has_member_submit
            =  requires(S&& s, R&& r)
               {
                   std::forward<S>(s).submit(std::forward<R>(r));
               }
            ;

        template <typename S, typename R>
        concept has_submit
            =  !has_member_submit<S, R>
            && requires(S&& s, R&& r)
               {
                   submit(std::forward<S>(s), std::forward<R>(r));
               }
            ;

        // --------------------------------------------------------------------

        template <typename S, typename R>
        struct submit_receiver
        {
            struct state
            {
                submit_receiver* d_sr;

                template <typename... A>
                    requires execution::receiver_of<R, A...>
                void set_value(A&&... a) && noexcept(execution::is_nothrow_receiver_of_v<R, A...>)
                {
                    execution::set_value(std::move(this->d_sr->d_r), std::forward<A>(a)...);
                    delete this->d_sr;
                }
                template <typename E>
                    requires execution::receiver<R, E>
                void set_error(E&& e) && noexcept
                {
                    execution::set_error(std::move(this->d_sr->d_r), std::forward<E>(e));
                    delete this->d_sr;
                }
                void set_done() && noexcept
                {
                    execution::set_done(std::move(this->d_sr->d_r));
                    delete this->d_sr;
                }
            };
            std::remove_cvref_t<R>                d_r;
            execution::connect_result_t<S, state> d_state;
            submit_receiver(S&& s, R&& r)
                : d_r(std::forward<R>(r))
                , d_state(execution::connect(std::forward<S>(s), state{this}))
            {
            }
        };

        // --------------------------------------------------------------------

        void submit();
        struct submit_t
        {
            template <typename S, typename R>
                requires execution::sender_to<S, R>
                      && has_member_submit<S, R>
            constexpr auto operator()(S&& s, R&& r) const
                noexcept(noexcept(std::forward<S>(s).submit(std::forward<R>(r))))
            {
                return std::forward<S>(s).submit(std::forward<R>(r));
            }
            template <typename S, typename R>
                requires execution::sender_to<S, R>
                      && has_submit<S, R>
            constexpr auto operator()(S&& s, R&& r) const
                noexcept(noexcept(submit(std::forward<S>(s), std::forward<R>(r))))
            {
                return submit(std::forward<S>(s), std::forward<R>(r));
            }
            
            template <typename S, typename R>
                requires execution::sender_to<S, R>
                      && (!has_member_submit<S, R>)
                      && (!has_submit<S, R>)
            constexpr auto operator()(S&& s, R&& r) const
            {
                return execution::start((new submit_receiver<S, R>(std::forward<S>(s), std::forward<R>(r)))->d_state);
            }
            
            template <typename S, typename R>
                requires (!execution::sender_to<S, R>)
            constexpr void operator()(S&&, R&&) const = delete;
        };
        inline constexpr submit_t submit_cp{};

        // --------------------------------------------------------------------
    }
    inline namespace customization_points
    {
        inline constexpr auto submit       = customization::submit_cp;
    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template<typename S>
    concept typed_sender
        =  sender<S>
        && detail::has_sender_types<sender_traits<std::remove_cvref_t<S>>>
        ;
}

// ----------------------------------------------------------------------------

namespace cxxrt::net::ip

{
    class address_v6;
    class address;
}

// ----------------------------------------------------------------------------

class cxxrt::net::ip::address
{
private:
    struct empty {};
    std::variant<empty, address_v4/*, address_v6*/> d_addr;

public:
    constexpr address() noexcept;
    /*-dk:TODO constexpr*/ address(address const& a) noexcept = default;
    /*-dk:TODO constexpr*/ address(address_v4 const& a) noexcept;
    constexpr address(address_v6 const& a) noexcept;

    address& operator=(address const& a) noexcept;
    address& operator=(address_v4 const& a) noexcept;
    address& operator=(address_v6 const& a) noexcept;

    constexpr bool is_v4() const noexcept { return this->d_addr.index() == 1; }
    constexpr bool is_v6() const noexcept { return this->d_addr.index() == 2; }
    constexpr address_v4 to_v4() const { return std::get<1>(this->d_addr); }
    constexpr address_v6 to_v6() const;
    constexpr bool is_unspecified() const noexcept;
    constexpr bool is_loopback() const noexcept;
    constexpr bool is_multicast() const noexcept;
    template<typename Allocator = std::allocator<char>>
    std::basic_string<char, std::char_traits<char>, Allocator>
    to_string(Allocator const& a = Allocator()) const;

    bool operator== (address const&) const;
    bool operator<  (address const&) const;
    template <typename cT, typename Traits>
    friend std::basic_ostream<cT, Traits>&
    operator<< (std::basic_ostream<cT, Traits>& out, address const& addr)
    {
        return out << addr.to_string();
    }
};

// ----------------------------------------------------------------------------

/*-dk:TODO constexpr*/ cxxrt::net::ip::address::address(address_v4 const& a) noexcept
    : d_addr(a)
{
}

// ----------------------------------------------------------------------------

template<typename Allocator>
std::basic_string<char, std::char_traits<char>, Allocator>
cxxrt::net::ip::address::to_string(Allocator const& a) const
{
    switch (this->d_addr.index())
    {
    default: return std::basic_string<char, std::char_traits<char>, Allocator>(a);
    case 1:  return std::get<1>(this->d_addr).to_string(a);
        //-dk:TODO: case 2: return std::get<2>(this->d_addr).to_string(a);
    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::net::ip

{
    using port_type = std::uint_least16_t;
    template <typename> class basic_endpoint;
}

// ----------------------------------------------------------------------------

template<typename InternetProtocol>
class cxxrt::net::ip::basic_endpoint
{
public:
    using protocol_type = InternetProtocol;

private:
    //-dk:TODO decompose/compose d_address/d_port
    cxxrt::net::ip::address d_address;
    port_type               d_port;
    mutable sockaddr_in     d_sockaddr; //-dk:TODO construct when setting address

public:
    constexpr basic_endpoint() noexcept;
    constexpr basic_endpoint(protocol_type const& proto,
                             port_type port_num) noexcept;
    constexpr basic_endpoint(cxxrt::net::ip::address const& addr,
                             port_type port_num) noexcept;

    constexpr protocol_type protocol() const noexcept;
    constexpr ip::address address() const noexcept { return this->d_address; }
    void address(cxxrt::net::ip::address const& addr) noexcept;
    constexpr port_type port() const noexcept { return this->d_port; }
    void port(port_type port_num) noexcept;

    bool operator== (basic_endpoint const&) const;
    bool operator<  (basic_endpoint const&) const;
    template <typename cT, typename Traits>
    friend std::basic_ostream<cT, Traits>&
    operator<< (std::basic_ostream<cT, Traits>& out, basic_endpoint const& e)
    {
        return out << e.address() << ':' << e.port();
    }

    sockaddr const* data() const;
    socklen_t       size() const { return sizeof(sockaddr_in); }
};

// ----------------------------------------------------------------------------

template<typename IP>
constexpr
cxxrt::net::ip::basic_endpoint<IP>::basic_endpoint(cxxrt::net::ip::address const& address,
                                                   port_type                      port) noexcept
    : d_address(address)
    , d_port(port)
{
}

// ----------------------------------------------------------------------------

template<typename IP>
constexpr auto
cxxrt::net::ip::basic_endpoint<IP>::protocol() const noexcept -> protocol_type
{
    return this->address().is_v6() ? protocol_type::v6() : protocol_type::v4();
}

// ----------------------------------------------------------------------------

template<typename IP>
sockaddr const*
cxxrt::net::ip::basic_endpoint<IP>::data() const
{
    this->d_sockaddr.sin_family      = AF_INET;
    this->d_sockaddr.sin_port        = htons(this->d_port);
    this->d_sockaddr.sin_addr.s_addr = this->d_address.to_v4().to_uint();
    return reinterpret_cast<sockaddr const*>(&this->d_sockaddr);
}

// ----------------------------------------------------------------------------

namespace cxxrt::net::ip

{
    class tcp;
}

// ----------------------------------------------------------------------------

class cxxrt::net::ip::tcp
{
private:
    int d_af;
    int d_pf;
    
    constexpr tcp(int af): d_af(af), d_pf() {}

public:
    using endpoint = cxxrt::net::ip::basic_endpoint<tcp>;
    using resolver = cxxrt::net::ip::basic_resolver<tcp>;

    using socket   = cxxrt::net::basic_stream_socket<tcp>;
    using acceptor = cxxrt::net::basic_socket_acceptor<tcp>;
    using iostream = cxxrt::net::basic_socket_iostream<tcp>;

    class no_delay;

    static constexpr tcp v4() noexcept { return tcp(AF_INET); }
    static constexpr tcp v6() noexcept { return tcp(AF_INET6); } 

    tcp() = delete;

    constexpr int domain()   const noexcept { return this->d_af; }
    constexpr int protocol() const noexcept { return this->d_pf; }

    friend constexpr bool operator==(const tcp& a, const tcp& b) noexcept;
};

// ----------------------------------------------------------------------------

namespace cxxrt::net

{
    namespace detail
    {
        class waiter;
    }
    class io_context;
}

// ----------------------------------------------------------------------------

class cxxrt::net::detail::waiter
{
protected:
    // The argument is the revents for thie corresponding file descriptor.
    // The function returns true if the entry is done and should be remove.
    virtual bool do_notify(int fd, short revents) = 0;

public:
    bool notify(int fd, short revents) { return this->do_notify(fd, revents); }
};

// ----------------------------------------------------------------------------

class cxxrt::net::io_context
    : public cxxrt::net::execution_context
    , private cxxrt::net::detail::waiter
{
public:
    class executor_type;
    class timer_base;
    using count_type = std::size_t;

    struct format_poll
    {
        short events;
        static std::ostream& print(std::ostream& out, short e);
        friend std::ostream& operator<< (std::ostream& out, format_poll f)
        {
            return print(out, f.events);
        }
    };
private:
    using time_point = std::chrono::steady_clock::time_point;
    struct timer_entry
    {
        timer_entry(time_point const& t, timer_base* b)
            : d_time(t)
            , d_timer(b)
        {
        }
        time_point  d_time;
        timer_base* d_timer;
        int timeout() const;
        friend bool operator< (timer_entry const& e1, timer_entry const& e2)
        {
            return e2.d_time < e1.d_time;
        }
    };
    std::priority_queue<timer_entry> d_timers;
    std::vector<pollfd>              d_watch;
    std::vector<detail::waiter*>     d_waiters; // matches d_watch
    int                              d_notify_fd;
    
protected:
    void wake_up();
    bool do_notify(int fd, short revents) override;

public:
    io_context();
    explicit io_context(int concurrency_hint);
    io_context(io_context const&) = delete;
    io_context& operator=(io_context const&) = delete;
    ~io_context();

    executor_type get_executor() noexcept;

    count_type run();
    count_type run_one();

    template<typename Rep, typename Period>
    count_type run_for(std::chrono::duration<Rep, Period> const& rel_time);
    template<typename Clock, typename Duration>
    count_type run_until(std::chrono::time_point<Clock, Duration> const& abs_time);
    template<typename Rep, typename Period>
    count_type run_one_for(std::chrono::duration<Rep, Period> const& rel_time);
    template<typename Clock, typename Duration>
    count_type run_one_until(std::chrono::time_point<Clock, Duration> const& abs_time);

    count_type poll();
    count_type poll_one();

    void stop();
    bool stopped() const noexcept;
    void restart();

    // custom
    void add(time_point const& time, timer_base* timer);
    void add(int fd, short events, cxxrt::net::detail::waiter* w);
};

// ----------------------------------------------------------------------------

class cxxrt::net::io_context::timer_base
{
protected:
    virtual void do_notify() = 0;
    virtual void do_cancel() = 0;

public:
    void notify() { this->do_notify(); }
    void cancel() { this->do_cancel(); }
};

// ----------------------------------------------------------------------------

class cxxrt::net::io_context::executor_type
{
private:
    cxxrt::net::io_context* d_context;
    
public:
    explicit executor_type(cxxrt::net::io_context* context)
        : d_context(context)
    {
    }

    executor_type(executor_type const& other) noexcept = default;
    executor_type(executor_type&& other) noexcept = default;
    executor_type& operator=(executor_type const& other) noexcept = default;
    executor_type& operator=(executor_type&& other) noexcept = default;

    bool running_in_this_thread() const noexcept;
    io_context& context() const noexcept { return *this->d_context; }
    void on_work_started() const noexcept;
    void on_work_finished() const noexcept;

    template<typename Func, typename ProtoAllocator>
    void dispatch(Func&& f, ProtoAllocator const& a) const;
    template<typename Func, typename ProtoAllocator>
    void post(Func&& f, ProtoAllocator const& a) const;
    template<typename Func, typename ProtoAllocator>
    void defer(Func&& f, ProtoAllocator const& a) const;

    friend bool operator==(io_context::executor_type const& a,
                           io_context::executor_type const& b) noexcept
    {
        return a.d_context == b.d_context;
    }
};

// ----------------------------------------------------------------------------

inline cxxrt::net::io_context::executor_type
cxxrt::net::io_context::get_executor() noexcept
{
    return executor_type(this);
}

// ----------------------------------------------------------------------------

namespace cxxrt::net

{
    template <typename...> class io_operation_base;
    template <typename, template <typename...> class, typename... >
    class io_operation;
}

// ----------------------------------------------------------------------------

template <typename... A>
class cxxrt::net::io_operation_base
    : public cxxrt::net::detail::waiter
{
protected:
    virtual void do_set_value(A...) = 0;
    virtual void do_set_error(std::error_code const&) noexcept = 0;
    virtual void do_set_error(std::exception_ptr const&) noexcept = 0;
    virtual void do_set_done() noexcept = 0;

public:
    void set_value(A... a) noexcept
        try
        {
            this->do_set_value(std::forward<A>(a)...);
        }
        catch(...)
        {
            this->set_error(std::current_exception());
        }
    void set_error(std::error_code const& ec) noexcept
    {
        this->do_set_error(ec);
    }
    void set_error(std::exception_ptr const& ep) noexcept
    {
        this->do_set_error(ep);
    }
    void set_done() noexcept
    {
        this->do_set_done();
    }
};

// ----------------------------------------------------------------------------

template <typename R, template <typename...> class Base, typename... A>
class cxxrt::net::io_operation
    : public Base<A...>
{
private:
    std::remove_cvref_t<R> d_receiver;
        
protected:
    void do_set_value(A... a) override
    {
        cxxrt::execution::set_value(std::move(this->d_receiver),
                                    std::forward<A>(a)...);
    }
    void do_set_error(std::error_code const& ec) noexcept override
    {
        cxxrt::execution::set_error(std::move(this->d_receiver), ec);
    }
    void do_set_error(std::exception_ptr const& ep) noexcept override
    {
        cxxrt::execution::set_error(std::move(this->d_receiver), ep);
    }
    void do_set_done() noexcept override
    {
        cxxrt::execution::set_done(std::move(this->d_receiver));
    }

public:
    template <typename T>
    io_operation(T&& r): d_receiver(std::forward<T>(r)) {}
};


// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template<typename> class just;
}

// ----------------------------------------------------------------------------

template<typename V>
class cxxrt::execution::just
{
private:
    std::remove_cvref_t<V> d_v;

public:
    template<template<typename...> class T, template<typename...> class Var>
    using value_types = Var<T<V>>;
    template<template<typename...> class Var>
    using error_types = Var<std::exception_ptr>;
    static constexpr bool sends_done = false;

    template<typename R>
    class state
    {
    private:
        V d_v;
        R d_r;

    public:
        template<typename T>
        state(T&& v, R&& r)
            : d_v(std::forward<T>(v))
            , d_r(std::forward<R>(r))
        {
        }
        void start() noexcept try
        {
            cxxrt::execution::set_value(std::move(this->d_r),
                                        std::move(this->d_v));
        }
        catch (...)
        {
            cxxrt::execution::set_error(std::move(this->d_r),
                                        std::current_exception());
        }
    };

    explicit just(V v): d_v(std::forward<V>(v)) {}

    template<typename R>
    state<R> connect(R&& r)
    {
        return state<R>{std::move(this->d_v), std::forward<R>(r)};
    }
};

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    // ------------------------------------------------------------------------
    // For creating a pipeline of senders the | operator can be used:
    // - the LHS is sender
    // - the RHS is a function taking a sender as parameter (the LHS) and
    //   returning a sender
    // See cxxrt::execution::then as an example. Thanks to Kirk Shoop for
    // pointing out the relationship between the two arguments.

    template <typename Sender, typename Fun>
        requires cxxrt::execution::sender<Sender>
    auto operator|(Sender&& sender, Fun&& fun)
    {
        return std::forward<Fun>(fun)(std::forward<Sender>(sender));
    }

    // ------------------------------------------------------------------------
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    template <typename, typename> class then_receiver;
    template <typename, typename> class then_sender;
    template <typename> class then_fun;

    template <typename Fun>
    then_fun<std::remove_cvref_t<Fun>> then(Fun&&);

    template <typename Sender, typename Fun>
    then_sender<std::remove_cvref_t<Sender>, std::remove_cvref_t<Fun>>
    then(Sender&&, Fun&&);
}

// ----------------------------------------------------------------------------

template <typename Fun>
class cxxrt::execution::then_fun
{
private:
    Fun d_fun;

public:
    template <typename F>
    then_fun(F&&);
    template <typename Sender>
    then_sender<std::remove_cvref_t<Sender>, Fun> operator()(Sender&&);
};

// ----------------------------------------------------------------------------

template <typename Receiver, typename Fun>
class cxxrt::execution::then_receiver
{
private:
    Receiver d_receiver;
    Fun      d_fun;

public:
    template <typename R, typename F>
    then_receiver(R&& r, F&& f)
        : d_receiver(std::forward<R>(r))
        , d_fun(std::forward<F>(f))
    {
    }
                  
    void set_value() && noexcept = delete; //-dk:TODO why is that needed?
    template <typename... A>
        requires cxxrt::execution::receiver_of<Receiver, std::invoke_result_t<Fun, A...>>
    void set_value(A&&... a) && noexcept try
    {
        cxxrt::execution::set_value(std::move(this->d_receiver),
                                    std::invoke(std::move(this->d_fun), std::forward<A>(a)...));
    }
    catch (...)
    {
        cxxrt::execution::set_error(std::move(this->d_receiver), std::current_exception());
    }
    template <typename... A>
        requires (!cxxrt::execution::receiver_of<Receiver, std::invoke_result_t<Fun, A...>>)
    void set_value(A&&... a) && noexcept try
    {
        std::invoke(std::move(this->d_fun), std::forward<A>(a)...);
        cxxrt::execution::set_value(std::move(this->d_receiver));
    }
    catch (...)
    {
        cxxrt::execution::set_error(std::move(this->d_receiver), std::current_exception());
    }
    template <typename E>
    void set_error(E&& e) && noexcept
    {
        cxxrt::execution::set_error(std::move(this->d_receiver), std::forward<E>(e));
    }
    void set_done() && noexcept
    {
        cxxrt::execution::set_done(std::move(this->d_receiver));
    }
};

// ----------------------------------------------------------------------------

template <typename Sender, typename Fun>
class cxxrt::execution::then_sender
    : public cxxrt::execution::sender_base
{
private:
    Sender d_sender;
    Fun    d_fun;

public:
    //-dk:TODO can this be a typed sender declaring value_types, error_types?
    //-dk:TODO the declaration can probably be leveraged from Sender

    template <typename S, typename F>
    then_sender(S&& sender, F&& fun)
        : d_sender(std::forward<S>(sender))
        , d_fun(std::forward<F>(fun))
    {
    }
    template <typename R>
    auto connect(R&& r) &&
    {
        return cxxrt::execution::connect(std::move(this->d_sender),
                                         then_receiver<R, Fun>{ std::forward<R>(r),
                                                                std::move(this->d_fun) });
    }
};

// ----------------------------------------------------------------------------

template <typename Fun>
    template <typename F>
cxxrt::execution::then_fun<Fun>::then_fun(F&& fun)
    : d_fun(std::forward<F>(fun))
{
}

template <typename Fun>
    template <typename Sender>
typename cxxrt::execution::then_sender<std::remove_cvref_t<Sender>, Fun>
cxxrt::execution::then_fun<Fun>::operator()(Sender&& sender)
{
    return { std::forward<Sender>(sender), std::move(this->d_fun) };
}

// ----------------------------------------------------------------------------

template <typename Fun>
cxxrt::execution::then_fun<std::remove_cvref_t<Fun>>
cxxrt::execution::then(Fun&& fun)
{
    // return cxxrt::execution::then_fun<std::remove_cvref_t<Fun>>(std::forward<Fun>(fun));
    return { std::forward<Fun>(fun) };
}

template <typename Sender, typename Fun>
cxxrt::execution::then_sender<std::remove_cvref_t<Sender>, std::remove_cvref_t<Fun>>
cxxrt::execution::then(Sender&& sender, Fun&& fun)
{
    return { std::forward<Sender>(sender), std::forward<Fun>(fun) };
}

// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    namespace detail { struct receiver; }
    template <typename Sender, typename Context>
    void sync_wait(Sender&&, Context&);
}
    
// ----------------------------------------------------------------------------

struct cxxrt::execution::detail::receiver
{
    std::atomic<bool>& d_done;
    
    template <typename... A>
    void set_value(A&&...) noexcept
    {
        this->d_done = true;
    }
    template <typename E>
    void set_error(E&&) noexcept
    {
        //-dk:TODO do something with the error!
        this->d_done = true;
    }
    void set_done() noexcept
    {
        this->d_done = true;
    }
};

// ----------------------------------------------------------------------------

template <typename Sender, typename Context>
void cxxrt::execution::sync_wait(Sender&& s, Context& context)
{
    std::atomic<bool> done(false);
    auto operation = cxxrt::execution::connect(std::forward<Sender>(s),
                                               detail::receiver{done});
    operation.start();
    while (!done)
    {
        context.run_one();
    }
}

// ----------------------------------------------------------------------------

namespace cxxrt::net

{
    class socket_base;
}

// ----------------------------------------------------------------------------

class cxxrt::net::socket_base
{
public:
    class broadcast;
    class debug;
    class do_not_route;
    class keep_alive;
    class linger;
    class out_of_band_inline;
    class receive_buffer_size;
    class receive_low_watermark;
    class reuse_address;
    class send_buffer_size;
    class send_low_watermark;

    using shutdown_type = int; //-dk:TODO 
    //-dk:TODO static constexpr shutdown_type shutdown_receive;
    //-dk:TODO static constexpr shutdown_type shutdown_send;
    //-dk:TODO static constexpr shutdown_type shutdown_both;

    using wait_type = int; //-dk:TODO 
    //-dk:TODO static constexpr wait_type wait_read;
    //-dk:TODO static constexpr wait_type wait_write;
    //-dk:TODO static constexpr wait_type wait_error;

    using message_flags = int; //-dk:TODO
    //-dk:TODO static constexpr message_flags message_peek;
    //-dk:TODO static constexpr message_flags message_out_of_band;
    //-dk:TODO static constexpr message_flags message_do_not_route;

    static const int max_listen_connections;

protected:
    socket_base();
    ~socket_base() = default;
};

// ----------------------------------------------------------------------------

namespace cxxrt::net

{
    template<typename> class basic_socket;
    template<typename...> class connect_operation;
}

// ----------------------------------------------------------------------------

template<typename Protocol>
class cxxrt::net::basic_socket
    : cxxrt::net::socket_base
{
private:
    cxxrt::net::io_context* d_context;
    int                     d_fd;

public:
    using executor_type      = cxxrt::net::io_context::executor_type;
    using native_handle_type = int;
    using protocol_type      = Protocol;
    using endpoint_type      = typename protocol_type::endpoint;

    cxxrt::net::io_context* context() noexcept { return this->d_context; } //-dk:TODO remove
    executor_type      get_executor() noexcept;
    native_handle_type native_handle() { return this->d_fd; }

    void open(protocol_type const& protocol = protocol_type());
    void open(protocol_type const& protocol, std::error_code& ec);
    void assign(protocol_type const& protocol,
                native_handle_type const& native_socket);
    void assign(protocol_type const& protocol,
                native_handle_type const& native_socket,
                std::error_code& ec);
    native_handle_type release(); // see 18.2.3
    native_handle_type release(std::error_code& ec); // see 18.2.3
    bool is_open() const noexcept { return this->d_fd != -1; }
    void close();
    void close(std::error_code& ec);
    void cancel();
    void cancel(std::error_code& ec);
    template<typename SettableSocketOption>
    void set_option(SettableSocketOption const& option);
    template<typename SettableSocketOption>
    void set_option(SettableSocketOption const& option, std::error_code& ec);
    template<typename GettableSocketOption>
    void get_option(GettableSocketOption& option) const;
    template<typename GettableSocketOption>
    void get_option(GettableSocketOption& option, std::error_code& ec) const;
    template<typename IoControlCommand>
    void io_control(IoControlCommand& command);
    template<typename IoControlCommand>
    void io_control(IoControlCommand& command, std::error_code& ec);
    void non_blocking(bool mode);
    void non_blocking(bool mode, std::error_code& ec);
    bool non_blocking() const;
    void native_non_blocking(bool mode);
    void native_non_blocking(bool mode, std::error_code& ec);
    bool native_non_blocking() const;
    bool at_mark() const;
    bool at_mark(std::error_code& ec) const;
    size_t available() const;
    size_t available(std::error_code& ec) const;
    void bind(endpoint_type const& endpoint);
    void bind(endpoint_type const& endpoint, std::error_code& ec);
    void shutdown(shutdown_type what);
    void shutdown(shutdown_type what, std::error_code& ec);
    endpoint_type local_endpoint() const;
    endpoint_type local_endpoint(std::error_code& ec) const;
    endpoint_type remote_endpoint() const;
    endpoint_type remote_endpoint(std::error_code& ec) const;
    void connect(endpoint_type const& endpoint);
    void connect(endpoint_type const& endpoint, std::error_code& ec);

    class async_connect_object;
    friend async_connect_object async_connect(basic_socket& s) { return {&s}; }
    auto async_connect(endpoint_type const& endpoint)
    {
        // return cxxrt::execution::just(endpoint) | async_connect_object{this};
        return async_connect_object{this}(cxxrt::execution::just(endpoint));
    }

    //-dk:TODO remove? template<cxxrt::execution::receiver R>
    //-dk:TODO remove? void async_connect(endpoint_type const& endpoint, R&& r);
    //-dk:TODO template<typename CompletionToken>
    //-dk:TODO DEDUCED async_connect(endpoint_type const& endpoint,
    //-dk:TODO                       CompletionToken&& token);

    void wait(wait_type w);
    void wait(wait_type w, std::error_code& ec);
    //-dk:TODO template<typename CompletionToken>
    //-dk:TODO DEDUCED async_wait(wait_type w, CompletionToken&& token);

protected:
    explicit basic_socket(cxxrt::net::io_context& ctx);
    basic_socket(cxxrt::net::io_context& ctx, protocol_type const& protocol);
    basic_socket(cxxrt::net::io_context& ctx, endpoint_type const& endpoint);
    basic_socket(cxxrt::net::io_context& ctx, protocol_type const& protocol,
                 native_handle_type const& native_socket);
    basic_socket(basic_socket const&) = delete;
    basic_socket(basic_socket&& rhs);
    template<typename OtherProtocol>
    basic_socket(basic_socket<OtherProtocol>&& rhs);
    ~basic_socket();

    basic_socket& operator=(basic_socket const&) = delete;
    basic_socket& operator=(basic_socket&& rhs);
    template<typename OtherProtocol>
    basic_socket& operator=(basic_socket<OtherProtocol>&& rhs);
};

// ----------------------------------------------------------------------------

template<typename Protocol>
cxxrt::net::basic_socket<Protocol>::basic_socket(cxxrt::net::io_context& ctx)
    : d_context(std::addressof(ctx))
    , d_fd(-1)
{
}

template<typename Protocol>
cxxrt::net::basic_socket<Protocol>::~basic_socket()
{
    if (this->d_fd != -1)
    {
        ::close(this->d_fd);
    }
}

// ----------------------------------------------------------------------------

template<typename Protocol>
void cxxrt::net::basic_socket<Protocol>::open(protocol_type const& protocol,
                                              std::error_code& ec)
{
    this->d_fd = ::socket(protocol.domain(), SOCK_STREAM, protocol.protocol());
    if (this->d_fd == -1)
    {
        ec.assign(errno, std::system_category());
    }
    else
    {
        int flags(::fcntl(this->d_fd, F_GETFL, 0));
        if (flags == 1
            || ::fcntl(this->d_fd, F_SETFL, flags | O_NONBLOCK) == -1)
        {
            ec.assign(errno, std::system_category());
            ::close(this->d_fd);
            this->d_fd = -1;
        }
    }
}

// ----------------------------------------------------------------------------

template<typename... A>
class cxxrt::net::connect_operation
    : public cxxrt::net::io_operation_base<A...>
{
protected:
    bool do_notify(int fd, short events) override
    {
        if (events & POLLOUT)
        {
            this->set_value();
        }
        else
        {
            socklen_t size(sizeof(int));
            int err(0), rc(::getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &size));
            this->set_error(std::error_code(rc == -1? errno: err,
                                            std::system_category()));
        }
        return true;
    }

    template<typename S, typename P>
    bool open(S* sock, P const& protocol)
    {
        if (sock->is_open())
        {
            return true;
        }
        std::error_code ec;
        sock->open(protocol, ec);
        return ec? this->set_error(ec), false: true;
    }

public:
    template<typename S, typename E>
    void start(S* sock, E const& ep)
    {
        if (!this->open(sock, ep.protocol()))
        {
            return;
        }
        if (::connect(sock->native_handle(), ep.data(), ep.size()) == -1)
        {
            if (errno != EINTR && errno != EINPROGRESS)
            {
                this->set_error(std::error_code(errno, std::system_category()));
                return;
            }
            sock->context()->add(sock->native_handle(), POLLOUT, this);
        }
        else
        {
            this->set_value();
        }
    }
};

// ----------------------------------------------------------------------------

template<typename Protocol>
class cxxrt::net::basic_socket<Protocol>::async_connect_object
{
public:
    template<typename R>
    class receiver
    {
    private:
        using Operation = cxxrt::net::io_operation<R, cxxrt::net::connect_operation>;
        Operation     d_op;
        basic_socket* d_s;
    public:
        template <typename Q>
        receiver(Q&& r, basic_socket* s)
            : d_op(std::forward<Q>(r))
            , d_s(s)
        {
        }

        template <typename... A>
        void set_value(A&&... a) noexcept {
            this->d_op.start(this->d_s, std::forward<A>(a)...);
        }
        void set_error(auto&& e)  noexcept { this->d_op.set_error(e); }
        void set_done()           noexcept { this->d_op.set_done(); }
    };
    template<typename Sender>
    class sender
        : public cxxrt::execution::sender_base
    {
    public:
        template<template<typename...> class T, template<typename...> class V>
        using value_types = V<T<>>; //-dk:TODO provide other side endpoint?
        template<template<typename...> class V>
        using error_types = V<std::error_code, std::exception_ptr>;
        //-dk:TODO conditionally define static constexpr bool sends_done = Sender::sends_done;

    private:
        Sender        d_sender;
        basic_socket* d_s;
        
    public:
        template <typename S>
        sender(S&& sender, basic_socket* sock)
            : d_sender(std::forward<S>(sender))
            , d_s(sock)
        {
        }

        template<typename R>
        auto connect(R&& r) &&
        {
            namespace EX = cxxrt::execution;
            return EX::connect(std::move(this->d_sender),
                               receiver<R>{ std::forward<R>(r), this->d_s });
        }
    };

private:
    basic_socket* d_s;

public:
    async_connect_object(basic_socket* s): d_s(s) {}

    template<typename S>
    sender<std::remove_cvref_t<S>> operator()(S&& s)
    {
        return {std::forward<S>(s), this->d_s};
    }
};

// ----------------------------------------------------------------------------

namespace cxxrt::net

{
    template <typename> class basic_stream_socket;
}

// ----------------------------------------------------------------------------

template<typename Protocol>
class cxxrt::net::basic_stream_socket
    : public cxxrt::net::basic_socket<Protocol>
{
public:
    using native_handle_type = int;
    using protocol_type = Protocol;
    using endpoint_type = typename protocol_type::endpoint;

    explicit basic_stream_socket(cxxrt::net::io_context& ctx);
    basic_stream_socket(cxxrt::net::io_context& ctx, protocol_type const& protocol);
    basic_stream_socket(cxxrt::net::io_context& ctx, endpoint_type const& endpoint);
    basic_stream_socket(cxxrt::net::io_context& ctx, protocol_type const& protocol,
                        native_handle_type const& native_socket);
    basic_stream_socket(basic_stream_socket const&) = delete;
    basic_stream_socket(basic_stream_socket&& rhs);
    template<typename OtherProtocol>
    basic_stream_socket(basic_stream_socket<OtherProtocol>&& rhs);
    ~basic_stream_socket() = default;

    basic_stream_socket& operator=(basic_stream_socket const&) = delete;
    basic_stream_socket& operator=(basic_stream_socket&& rhs);
    template<typename OtherProtocol>
    basic_stream_socket& operator=(basic_stream_socket<OtherProtocol>&& rhs);

    template<typename MutableBufferSequence>
    size_t receive(MutableBufferSequence const& buffers);
    template<typename MutableBufferSequence>
    size_t receive(MutableBufferSequence const& buffers,
                   std::error_code& ec);
    template<typename MutableBufferSequence>
    size_t receive(MutableBufferSequence const& buffers,
                   socket_base::message_flags flags);
    template<typename MutableBufferSequence>
    size_t receive(MutableBufferSequence const& buffers,
                   socket_base::message_flags flags, std::error_code& ec);

    template <typename MutableBufferSequence>
    struct receive_sender;
    template <typename MutableBufferSequence>
    receive_sender<MutableBufferSequence> async_receive(MutableBufferSequence const& buffers);
    struct async_receive_object
    {
        basic_stream_socket* d_s;
        template <typename MutableBufferSequence>
        receive_sender<MutableBufferSequence> operator()(MutableBufferSequence const& buffers)
        {
            return this->d_s->async_receive(buffers);
        }
    };
    friend async_receive_object async_receive(basic_stream_socket& s) { return {&s}; }
    //-dk:TODO template<typename MutableBufferSequence, typename CompletionToken>
    //-dk:TODO DEDUCED async_receive(MutableBufferSequence const& buffers,
    //-dk:TODO                       CompletionToken&& token);
    //-dk:TODO template<typename MutableBufferSequence, typename CompletionToken>
    //-dk:TODO DEDUCED async_receive(MutableBufferSequence const& buffers,
    //-dk:TODO                       socket_base::message_flags flags,
    //-dk:TODO                       CompletionToken&& token);
    template<typename ConstBufferSequence>
    size_t send(ConstBufferSequence const& buffers);
    template<typename ConstBufferSequence>
    size_t send(ConstBufferSequence const& buffers, std::error_code& ec);
    template<typename ConstBufferSequence>
    size_t send(ConstBufferSequence const& buffers,
                socket_base::message_flags flags);
    template<typename ConstBufferSequence>
    size_t send(ConstBufferSequence const& buffers,
                socket_base::message_flags flags, std::error_code& ec);

    template <typename ConstBufferSequence>
    struct send_sender;
    template <typename ConstBufferSequence>
    send_sender<ConstBufferSequence> async_send(ConstBufferSequence const& buffers);
    struct async_send_object
    {
        basic_stream_socket* d_s;
        template <typename ConstBufferSequence>
        send_sender<ConstBufferSequence> operator()(ConstBufferSequence const& buffers)
        {
            return this->d_s->async_send(buffers);
        }
    };
    friend async_send_object async_send(basic_stream_socket& s) { return {&s}; }
    
    //-dk:TODO template<typename ConstBufferSequence, typename CompletionToken>
    //-dk:TODO DEDUCED async_send(ConstBufferSequence const& buffers,
    //-dk:TODO                    CompletionToken&& token);
    //-dk:TODO template<typename ConstBufferSequence, typename CompletionToken>
    //-dk:TODO DEDUCED async_send(ConstBufferSequence const& buffers,
    //-dk:TODO                    socket_base::message_flags flags,
    //-dk:TODO                    CompletionToken&& token);
    template<typename MutableBufferSequence>
    size_t read_some(MutableBufferSequence const& buffers);
    template<typename MutableBufferSequence>
    size_t read_some(MutableBufferSequence const& buffers,
                     std::error_code& ec);
    //-dk:TODO template<typename MutableBufferSequence, typename CompletionToken>
    //-dk:TODO DEDUCED async_read_some(MutableBufferSequence const& buffers,
    //-dk:TODO                         CompletionToken&& token);
    template<typename ConstBufferSequence>
    size_t write_some(ConstBufferSequence const& buffers);
    template<typename ConstBufferSequence>
    size_t write_some(ConstBufferSequence const& buffers,
                      std::error_code& ec);
    //-dk:TODO template<typename ConstBufferSequence, typename CompletionToken>
    //-dk:TODO DEDUCED async_write_some(ConstBufferSequence const& buffers,
    //-dk:TODO                          CompletionToken&& token);
};

// ----------------------------------------------------------------------------

template<typename Protocol>
cxxrt::net::basic_stream_socket<Protocol>::basic_stream_socket(cxxrt::net::io_context& ctx)
    : cxxrt::net::basic_socket<Protocol>(ctx)
{
}

// ----------------------------------------------------------------------------

template <typename Protocol>
template <typename ConstBufferSequence>
struct cxxrt::net::basic_stream_socket<Protocol>::send_sender
    : cxxrt::execution::sender_base
{
private:
    friend class basic_stream_socket;

    basic_stream_socket*       d_socket;
    ConstBufferSequence const& d_buffers;
    send_sender(basic_stream_socket* s, ConstBufferSequence const& b)
        : d_socket(s),
          d_buffers(b)
    {
    }

public:
    //-dk:TODO report amount write?
    template <template <typename...> class T,
              template <typename...> class V>
    using value_types = V<T<>>;
    template <template <typename...> class V>
    using error_types = V<std::error_code, std::exception_ptr>;

    static constexpr bool sends_done = false;

    template <typename R>
    struct state
        : cxxrt::net::detail::waiter
    {
    private:
        basic_stream_socket*       d_socket;
        ConstBufferSequence const& d_buffers;
        R                          d_r;

        bool do_notify(int, short events) override
        {
            if (events & POLLOUT)
            {
                //-dk:TODO write some and signal upon done/error
            }
            return true;
        }

    public:
        state(basic_stream_socket* s, ConstBufferSequence const& b, R r)
            : d_socket(s)
            , d_buffers(b)
            , d_r(std::forward<R>(r))
        {
        }
        void operator= (state&&) = delete;
        void start() noexcept
        {
            //-dk:TODO 
            if (!this->d_socket->is_open())
            {
                std::error_code ec;
                execution::set_error(std::move(this->d_r), ec);
                return;
            }
            this->d_socket->context()->add(this->d_socket->native_handle(), POLLOUT, this);
        }
    };

    template <typename R>
    state<R> connect(R&& r) {
        return state<R>(this->d_socket, this->d_buffers, std::forward<R>(r));
    }
};

template <typename Protocol>
template <typename ConstBufferSequence>
auto cxxrt::net::basic_stream_socket<Protocol>::async_send(ConstBufferSequence const& b)
    -> send_sender<ConstBufferSequence>
{
    return send_sender<ConstBufferSequence>{this, b};
}


// ----------------------------------------------------------------------------

namespace cxxrt::execution

{
    struct context_t {};
    constexpr context_t context;

    struct blocking_t {};
    constexpr blocking_t blocking;

    struct blocking_adaptation_t {};
    constexpr blocking_adaptation_t blocking_adaptation;

    struct relationship_t {};
    constexpr relationship_t relationship;

    struct outstanding_work_t {};
    constexpr outstanding_work_t outstanding_work;

    struct bulk_guarantee_t {};
    constexpr bulk_guarantee_t bulk_guarantee;

    struct mapping_t {};
    constexpr mapping_t mapping;

    template <typename ProtoAllocator>
    struct allocator_t {};
    constexpr allocator_t<void> allocator;

    template<typename Executor> struct executor_shape;
    template<typename Executor> struct executor_index;

    template<typename Executor> using executor_shape_t = typename executor_shape<Executor>::type;
    template<typename Executor> using executor_index_t = typename executor_index<Executor>::type;

    class bad_executor;
    
    template <typename... SupportableProperties> class any_executor;

    template<typename Property> struct prefer_only;

} // namespace cxxrt::execution

// ----------------------------------------------------------------------------


namespace cxxrt::net

{
    template <typename> class basic_socket_acceptor;
}

// ----------------------------------------------------------------------------

namespace cxxrt::net

{
    template<typename> struct wait_traits;
    template<typename, typename> class basic_waitable_timer;

    using system_timer = basic_waitable_timer<std::chrono::system_clock>;
    using steady_timer = basic_waitable_timer<std::chrono::steady_clock>;
    using high_resolution_timer = basic_waitable_timer<std::chrono::high_resolution_clock>; 
}

// ----------------------------------------------------------------------------

template<typename Clock>
struct cxxrt::net::wait_traits
{
    using duration   = typename Clock::duration;
    using time_point = typename Clock::time_point;
    
    static auto to_wait_duration(duration const& d) -> duration;
    static auto to_wait_duration(time_point const& t) -> duration;
};

// ----------------------------------------------------------------------------

template<typename Clock, typename WaitTraits>
class cxxrt::net::basic_waitable_timer
{
public:
    using executor_type = io_context::executor_type;
    using clock_type    = Clock;
    using duration      = typename clock_type::duration;
    using time_point    = typename clock_type::time_point;
    using traits_type   = WaitTraits;
    using timer_base    = io_context::timer_base;
    struct sender;

private:
    cxxrt::net::io_context* d_context;
    time_point              d_expiry;

    void add(timer_base* s)
    {
        this->d_context->add(this->d_expiry, s);
    }

public:
    explicit basic_waitable_timer(io_context& c);
    basic_waitable_timer(io_context& c, time_point const& t);
    basic_waitable_timer(io_context& c, duration const& d);
    basic_waitable_timer(basic_waitable_timer const&) = delete;
    basic_waitable_timer(basic_waitable_timer&& rhs) = delete; //-dk:TODO
    ~basic_waitable_timer() = default;

    basic_waitable_timer& operator=(basic_waitable_timer const&) = delete;
    basic_waitable_timer& operator=(basic_waitable_timer&& rhs) = delete; //-dk:TODO

    executor_type get_executor() noexcept;
    std::size_t cancel();
    std::size_t cancel_one();
    time_point  expiry() const;
    std::size_t expires_at(time_point const& t);
    std::size_t expires_after(duration const& d);

    sender sender_wait();
    
    void wait();
    void wait(std::error_code& ec);
    //-dk:TODO template<typename CompletionToken> DEDUCED async_wait(CompletionToken&& token);
};

// ----------------------------------------------------------------------------

template<typename C, typename W>
struct cxxrt::net::basic_waitable_timer<C, W>::sender
{
public:
    template <template <typename...> class, template <typename...> class V>
    using value_types = V<>;
    template <template <typename...> class V>
    using error_types = V<std::exception_ptr>;

    static constexpr bool sends_done = true;

    template <typename R>
    struct state final
        : cxxrt::net::io_context::timer_base
    {
    private:
        basic_waitable_timer* d_timer;
        R                     d_r;

    public:
        template <typename S>
        state(basic_waitable_timer* t, S&& r)
            : d_timer(t)
            , d_r(std::forward<S>(r))
        {
        }
        void do_notify() override try
        {
            std::move(this->d_r).set_value();
        }
        catch (...)
        {
            std::move(this->d_r).set_error(std::current_exception());
        }
        void do_cancel() override { std::move(this->d_r).set_done(); }
        void start() noexcept try
        {
            this->d_timer->add(this);
        }
        catch (...)
        {
            std::move(this->d_r).set_error(std::current_exception());
        }
    };

private:
    basic_waitable_timer* d_timer;
    
public:
    explicit sender(basic_waitable_timer* t): d_timer(t) {}

    template <typename R>
    auto connect(R&& r) { return state<R> { this->d_timer, std::move(r) }; }
};

// ----------------------------------------------------------------------------

template<typename Clock>
inline auto
cxxrt::net::wait_traits<Clock>::to_wait_duration(duration const& d)
    -> duration
{
    return d;
}
template<typename Clock>
inline auto
cxxrt::net::wait_traits<Clock>::to_wait_duration(time_point const& t)
    -> duration
{
    //-dk:TODO deal with duration boundary conditions
    auto now = Clock::now();
    return t - now;
}

// ----------------------------------------------------------------------------

template<typename C, typename W>
cxxrt::net::basic_waitable_timer<C, W>::basic_waitable_timer(io_context& c)
    : basic_waitable_timer(c, time_point{})
{
}

template<typename C, typename W>
cxxrt::net::basic_waitable_timer<C, W>::basic_waitable_timer(io_context&       c,
                                                             time_point const& t)
    : d_context(std::addressof(c))
    , d_expiry(t)
{
}

template<typename C, typename W>
cxxrt::net::basic_waitable_timer<C, W>::basic_waitable_timer(io_context&     c,
                                                             duration const& d)
    : basic_waitable_timer(c, clock_type::now() + d)
{
}

// ----------------------------------------------------------------------------

template<typename C, typename W>
auto cxxrt::net::basic_waitable_timer<C, W>::expiry() const
    -> time_point
{
    return this->d_expiry;
}

template<typename C, typename W>
auto cxxrt::net::basic_waitable_timer<C, W>::cancel_one()
    -> std::size_t
{
    //-dk:TODO cancel waiting operations
    return 0u;
}

template<typename C, typename W>
auto cxxrt::net::basic_waitable_timer<C, W>::cancel()
    -> std::size_t
{
    std::size_t n{};
    while (auto c = this->cancel_one())
    {
        n += c;
    }
    return n;
}

template<typename C, typename W>
auto cxxrt::net::basic_waitable_timer<C, W>::expires_at(time_point const& t)
    -> std::size_t
{
    std::size_t n{this->cancel()};
    this->d_expiry = t;
    return n;
}

template<typename C, typename W>
auto cxxrt::net::basic_waitable_timer<C, W>::expires_after(duration const& d)
    -> std::size_t
{
    return this->expires_at(clock_type::now() + d);
}

// ----------------------------------------------------------------------------

template<typename C, typename W>
auto cxxrt::net::basic_waitable_timer<C, W>::sender_wait()
    -> sender
{
    return sender(this);
}


// ----------------------------------------------------------------------------


#endif
